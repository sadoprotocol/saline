/*! For license information please see bundle.js.LICENSE.txt */
(()=>{var t,e,r={320:(t,e)=>{"use strict";function r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function n(t){if("boolean"!=typeof t)throw new Error(`Expected boolean, not ${t}`)}function i(t,...e){if(!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function o(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(t.outputLen),r(t.blockLen)}function s(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function a(t,e){i(t);const r=e.outputLen;if(t.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}Object.defineProperty(e,"__esModule",{value:!0}),e.output=e.exists=e.hash=e.bytes=e.bool=e.number=void 0,e.number=r,e.bool=n,e.bytes=i,e.hash=o,e.exists=s,e.output=a;const c={number:r,bool:n,bytes:i,hash:o,exists:s,output:a};e.default=c},505:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SHA2=void 0;const n=r(320),i=r(89);class o extends i.Hash{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,i.createView)(this.buffer)}update(t){n.default.exists(this);const{view:e,buffer:r,blockLen:o}=this,s=(t=(0,i.toBytes)(t)).length;for(let n=0;n<s;){const a=Math.min(o-this.pos,s-n);if(a!==o)r.set(t.subarray(n,n+a),this.pos),this.pos+=a,n+=a,this.pos===o&&(this.process(e,0),this.pos=0);else{const e=(0,i.createView)(t);for(;o<=s-n;n+=o)this.process(e,n)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){n.default.exists(this),n.default.output(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:s}=this;let{pos:a}=this;e[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>o-a&&(this.process(r,0),a=0);for(let t=a;t<o;t++)e[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),a=Number(r&o),c=n?4:0,u=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+u,a,n)}(r,o-8,BigInt(8*this.length),s),this.process(r,0);const c=(0,i.createView)(t),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=u/4,f=this.get();if(h>f.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<h;t++)c.setUint32(4*t,f[t],s)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:i,destroyed:o,pos:s}=this;return t.length=n,t.pos=s,t.finished=i,t.destroyed=o,n%e&&t.buffer.set(r),t}}e.SHA2=o},945:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=void 0,e.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},569:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.hmac=void 0;const n=r(320),i=r(89);class o extends i.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,n.default.hash(t);const r=(0,i.toBytes)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){return n.default.exists(this),this.iHash.update(t),this}digestInto(t){n.default.exists(this),n.default.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:i,blockLen:o,outputLen:s}=this;return t.finished=n,t.destroyed=i,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}e.hmac=(t,e,r)=>new o(t,e).update(r).digest(),e.hmac.create=(t,e)=>new o(t,e)},61:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sha224=e.sha256=void 0;const n=r(505),i=r(89),o=(t,e,r)=>t&e^t&r^e&r,s=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),a=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),c=new Uint32Array(64);class u extends n.SHA2{constructor(){super(64,32,8,!1),this.A=0|a[0],this.B=0|a[1],this.C=0|a[2],this.D=0|a[3],this.E=0|a[4],this.F=0|a[5],this.G=0|a[6],this.H=0|a[7]}get(){const{A:t,B:e,C:r,D:n,E:i,F:o,G:s,H:a}=this;return[t,e,r,n,i,o,s,a]}set(t,e,r,n,i,o,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)c[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=c[t-15],r=c[t-2],n=(0,i.rotr)(e,7)^(0,i.rotr)(e,18)^e>>>3,o=(0,i.rotr)(r,17)^(0,i.rotr)(r,19)^r>>>10;c[t]=o+c[t-7]+n+c[t-16]|0}let{A:r,B:n,C:a,D:u,E:h,F:f,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,i.rotr)(h,6)^(0,i.rotr)(h,11)^(0,i.rotr)(h,25))+((y=h)&f^~y&l)+s[t]+c[t]|0,p=((0,i.rotr)(r,2)^(0,i.rotr)(r,13)^(0,i.rotr)(r,22))+o(r,n,a)|0;d=l,l=f,f=h,h=u+e|0,u=a,a=n,n=r,r=e+p|0}var y;r=r+this.A|0,n=n+this.B|0,a=a+this.C|0,u=u+this.D|0,h=h+this.E|0,f=f+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(r,n,a,u,h,f,l,d)}roundClean(){c.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class h extends u{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}e.sha256=(0,i.wrapConstructor)((()=>new u)),e.sha224=(0,i.wrapConstructor)((()=>new h))},89:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.randomBytes=e.wrapConstructorWithOpts=e.wrapConstructor=e.checkOpts=e.Hash=e.concatBytes=e.toBytes=e.utf8ToBytes=e.asyncLoop=e.nextTick=e.hexToBytes=e.bytesToHex=e.isLE=e.rotr=e.createView=e.u32=e.u8=void 0;const n=r(945);if(e.u8=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),e.u32=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),e.createView=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),e.rotr=(t,e)=>t<<32-e|t>>>e,e.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],!e.isLE)throw new Error("Non little-endian hardware is not supported");const i=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function o(t){if("string"!=typeof t)throw new TypeError("utf8ToBytes expected string, got "+typeof t);return(new TextEncoder).encode(t)}function s(t){if("string"==typeof t&&(t=o(t)),!(t instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);return t}e.bytesToHex=function(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=i[t[r]];return e},e.hexToBytes=function(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,i=t.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[r]=o}return e},e.nextTick=async()=>{},e.asyncLoop=async function(t,r,n){let i=Date.now();for(let o=0;o<t;o++){n(o);const t=Date.now()-i;t>=0&&t<r||(await(0,e.nextTick)(),i+=t)}},e.utf8ToBytes=o,e.toBytes=s,e.concatBytes=function(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r},e.Hash=class{clone(){return this._cloneInto()}},e.checkOpts=function(t,e){if(void 0!==e&&("object"!=typeof e||(r=e,"[object Object]"!==Object.prototype.toString.call(r)||r.constructor!==Object)))throw new TypeError("Options should be object or undefined");var r;return Object.assign(t,e)},e.wrapConstructor=function(t){const e=e=>t().update(s(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e},e.wrapConstructorWithOpts=function(t){const e=(e,r)=>t(r).update(s(e)).digest(),r=t({});return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=e=>t(e),e},e.randomBytes=function(t=32){if(n.crypto&&"function"==typeof n.crypto.getRandomValues)return n.crypto.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}},656:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.utils=e.schnorr=e.verify=e.signSync=e.sign=e.getSharedSecret=e.recoverPublicKey=e.getPublicKey=e.Signature=e.Point=e.CURVE=void 0;const n=r(159),i=BigInt(0),o=BigInt(1),s=BigInt(2),a=BigInt(3),c=BigInt(8),u=Object.freeze({a:i,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:o,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")});e.CURVE=u;const h=(t,e)=>(t+e/s)/e,f={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(t){const{n:e}=u,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-o*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=r,a=BigInt("0x100000000000000000000000000000000"),c=h(s*t,e),f=h(-n*t,e);let l=R(t-c*r-f*i,e),d=R(-c*n-f*s,e);const y=l>a,p=d>a;if(y&&(l=e-l),p&&(d=e-d),l>a||d>a)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:y,k1:l,k2neg:p,k2:d}}},l=32,d=32,y=l+1,p=2*l+1;function g(t){const{a:e,b:r}=u,n=R(t*t),i=R(n*t);return R(i+e*t+r)}const w=u.a===i;class b extends Error{constructor(t){super(t)}}function m(t){if(!(t instanceof v))throw new TypeError("JacobianPoint expected")}class v{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static fromAffine(t){if(!(t instanceof S))throw new TypeError("JacobianPoint#fromAffine: expected Point");return t.equals(S.ZERO)?v.ZERO:new v(t.x,t.y,o)}static toAffineBatch(t){const e=function(t,e=u.P){const r=new Array(t.length),n=D(t.reduce(((t,n,o)=>n===i?t:(r[o]=t,R(t*n,e))),o),e);return t.reduceRight(((t,n,o)=>n===i?t:(r[o]=R(t*r[o],e),R(t*n,e))),n),r}(t.map((t=>t.z)));return t.map(((t,r)=>t.toAffine(e[r])))}static normalizeZ(t){return v.toAffineBatch(t).map(v.fromAffine)}equals(t){m(t);const{x:e,y:r,z:n}=this,{x:i,y:o,z:s}=t,a=R(n*n),c=R(s*s),u=R(e*c),h=R(i*a),f=R(R(r*s)*c),l=R(R(o*n)*a);return u===h&&f===l}negate(){return new v(this.x,R(-this.y),this.z)}double(){const{x:t,y:e,z:r}=this,n=R(t*t),i=R(e*e),o=R(i*i),u=t+i,h=R(s*(R(u*u)-n-o)),f=R(a*n),l=R(f*f),d=R(l-s*h),y=R(f*(h-d)-c*o),p=R(s*e*r);return new v(d,y,p)}add(t){m(t);const{x:e,y:r,z:n}=this,{x:o,y:a,z:c}=t;if(o===i||a===i)return this;if(e===i||r===i)return t;const u=R(n*n),h=R(c*c),f=R(e*h),l=R(o*u),d=R(R(r*c)*h),y=R(R(a*n)*u),p=R(l-f),g=R(y-d);if(p===i)return g===i?this.double():v.ZERO;const w=R(p*p),b=R(p*w),E=R(f*w),x=R(g*g-b-s*E),S=R(g*(E-x)-d*b),A=R(n*c*p);return new v(x,S,A)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=v.ZERO;if("bigint"==typeof t&&t===i)return e;let r=L(t);if(r===o)return this;if(!w){let t=e,n=this;for(;r>i;)r&o&&(t=t.add(n)),n=n.double(),r>>=o;return t}let{k1neg:n,k1:s,k2neg:a,k2:c}=f.splitScalar(r),u=e,h=e,l=this;for(;s>i||c>i;)s&o&&(u=u.add(l)),c&o&&(h=h.add(l)),l=l.double(),s>>=o,c>>=o;return n&&(u=u.negate()),a&&(h=h.negate()),h=new v(R(h.x*f.beta),h.y,h.z),u.add(h)}precomputeWindow(t){const e=w?128/t+1:256/t+1,r=[];let n=this,i=n;for(let o=0;o<e;o++){i=n,r.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(n),r.push(i);n=i.double()}return r}wNAF(t,e){!e&&this.equals(v.BASE)&&(e=S.BASE);const r=e&&e._WINDOW_SIZE||1;if(256%r)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let n=e&&x.get(e);n||(n=this.precomputeWindow(r),e&&1!==r&&(n=v.normalizeZ(n),x.set(e,n)));let i=v.ZERO,s=v.BASE;const a=1+(w?128/r:256/r),c=2**(r-1),u=BigInt(2**r-1),h=2**r,f=BigInt(r);for(let e=0;e<a;e++){const r=e*c;let a=Number(t&u);t>>=f,a>c&&(a-=h,t+=o);const l=r,d=r+Math.abs(a)-1,y=e%2!=0,p=a<0;0===a?s=s.add(E(y,n[l])):i=i.add(E(p,n[d]))}return{p:i,f:s}}multiply(t,e){let r,n,i=L(t);if(w){const{k1neg:t,k1:o,k2neg:s,k2:a}=f.splitScalar(i);let{p:c,f:u}=this.wNAF(o,e),{p:h,f:l}=this.wNAF(a,e);c=E(t,c),h=E(s,h),h=new v(R(h.x*f.beta),h.y,h.z),r=c.add(h),n=u.add(l)}else{const{p:t,f:o}=this.wNAF(i,e);r=t,n=o}return v.normalizeZ([r,n])[0]}toAffine(t){const{x:e,y:r,z:n}=this,i=this.equals(v.ZERO);null==t&&(t=i?c:D(n));const s=t,a=R(s*s),u=R(a*s),h=R(e*a),f=R(r*u),l=R(n*s);if(i)return S.ZERO;if(l!==o)throw new Error("invZ was invalid");return new S(h,f)}}function E(t,e){const r=e.negate();return t?r:e}v.BASE=new v(u.Gx,u.Gy,o),v.ZERO=new v(i,o,i);const x=new WeakMap;class S{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,x.delete(this)}hasEvenY(){return this.y%s===i}static fromCompressedHex(t){const e=32===t.length,r=M(e?t:t.subarray(1));if(!J(r))throw new Error("Point is not on curve");let n=function(t){const{P:e}=u,r=BigInt(6),n=BigInt(11),i=BigInt(22),o=BigInt(23),c=BigInt(44),h=BigInt(88),f=t*t*t%e,l=f*f*t%e,d=$(l,a)*l%e,y=$(d,a)*l%e,p=$(y,s)*f%e,g=$(p,n)*p%e,w=$(g,i)*g%e,b=$(w,c)*w%e,m=$(b,h)*b%e,v=$(m,c)*w%e,E=$(v,a)*l%e,x=$(E,o)*g%e,S=$(x,r)*f%e,A=$(S,s);if(A*A%e!==t)throw new Error("Cannot find square root");return A}(g(r));const i=(n&o)===o;e?i&&(n=R(-n)):1==(1&t[0])!==i&&(n=R(-n));const c=new S(r,n);return c.assertValidity(),c}static fromUncompressedHex(t){const e=M(t.subarray(1,l+1)),r=M(t.subarray(l+1,2*l+1)),n=new S(e,r);return n.assertValidity(),n}static fromHex(t){const e=N(t),r=e.length,n=e[0];if(r===l)return this.fromCompressedHex(e);if(r===y&&(2===n||3===n))return this.fromCompressedHex(e);if(r===p&&4===n)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-${y} compressed bytes or ${p} uncompressed bytes, not ${r}`)}static fromPrivateKey(t){return S.BASE.multiply(Z(t))}static fromSignature(t,e,r){const{r:n,s:i}=X(e);if(![0,1,2,3].includes(r))throw new Error("Cannot recover: invalid recovery bit");const o=K(N(t)),{n:s}=u,a=2===r||3===r?n+s:n,c=D(a,s),h=R(-o*c,s),f=R(i*c,s),l=1&r?"03":"02",d=S.fromHex(l+T(a)),y=S.BASE.multiplyAndAddUnsafe(d,h,f);if(!y)throw new Error("Cannot recover signature: point at infinify");return y.assertValidity(),y}toRawBytes(t=!1){return I(this.toHex(t))}toHex(t=!1){const e=T(this.x);return t?`${this.hasEvenY()?"02":"03"}${e}`:`04${e}${T(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:r}=this;if(!J(e)||!J(r))throw new Error(t);const n=R(r*r);if(R(n-g(e))!==i)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new S(this.x,R(-this.y))}double(){return v.fromAffine(this).double().toAffine()}add(t){return v.fromAffine(this).add(v.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return v.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,r){const n=v.fromAffine(this),s=e===i||e===o||this!==S.BASE?n.multiplyUnsafe(e):n.multiply(e),a=v.fromAffine(t).multiplyUnsafe(r),c=s.add(a);return c.equals(v.ZERO)?void 0:c.toAffine()}}function A(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function P(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${C(t)}`);const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===r[0]&&r[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:M(r),left:t.subarray(e+2)}}e.Point=S,S.BASE=new S(u.Gx,u.Gy),S.ZERO=new S(i,i);class B{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=t instanceof Uint8Array,r="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${r}: Expected string or Uint8Array`);const n=e?C(t):t;if(128!==n.length)throw new Error(`${r}: Expected 64-byte hex`);return new B(k(n.slice(0,64)),k(n.slice(64,128)))}static fromDER(t){const e=t instanceof Uint8Array;if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r,s:n}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${C(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:r}=P(t.subarray(2)),{data:n,left:i}=P(r);if(i.length)throw new Error(`Invalid signature: left bytes after parsing: ${C(i)}`);return{r:e,s:n}}(e?t:I(t));return new B(r,n)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!W(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!W(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=u.n>>o;return this.s>t}normalizeS(){return this.hasHighS()?new B(this.r,R(-this.s,u.n)):this}toDERRawBytes(){return I(this.toDERHex())}toDERHex(){const t=A(j(this.s)),e=A(j(this.r)),r=t.length/2,n=e.length/2,i=j(r),o=j(n);return`30${j(n+r+4)}02${o}${e}02${i}${t}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return I(this.toCompactHex())}toCompactHex(){return T(this.r)+T(this.s)}}function O(...t){if(!t.every((t=>t instanceof Uint8Array)))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const i=t[e];r.set(i,n),n+=i.length}return r}e.Signature=B;const _=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function C(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let r=0;r<t.length;r++)e+=_[t[r]];return e}const H=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function T(t){if("bigint"!=typeof t)throw new Error("Expected bigint");if(!(i<=t&&t<H))throw new Error("Expected number 0 <= n < 2^256");return t.toString(16).padStart(64,"0")}function U(t){const e=I(T(t));if(32!==e.length)throw new Error("Error: expected 32 bytes");return e}function j(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function k(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function I(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let r=0;r<e.length;r++){const n=2*r,i=t.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[r]=o}return e}function M(t){return k(C(t))}function N(t){return t instanceof Uint8Array?Uint8Array.from(t):I(t)}function L(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&W(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function R(t,e=u.P){const r=t%e;return r>=i?r:e+r}function $(t,e){const{P:r}=u;let n=t;for(;e-- >i;)n*=n,n%=r;return n}function D(t,e=u.P){if(t===i||e<=i)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let r=R(t,e),n=e,s=i,a=o,c=o,h=i;for(;r!==i;){const t=n/r,e=n%r,i=s-c*t,o=a-h*t;n=r,r=e,s=c,a=h,c=i,h=o}if(n!==o)throw new Error("invert: does not exist");return R(s,e)}function K(t,e=!1){const r=function(t){const e=8*t.length-8*d,r=M(t);return e>0?r>>BigInt(e):r}(t);if(e)return r;const{n}=u;return r>=n?r-n:r}let q,z;class V{constructor(t,e){if(this.hashLen=t,this.qByteLen=e,"number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(t).fill(1),this.k=new Uint8Array(t).fill(0),this.counter=0}hmac(...t){return e.utils.hmacSha256(this.k,...t)}hmacSync(...t){return z(this.k,...t)}checkSync(){if("function"!=typeof z)throw new b("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){this.incr();let t=0;const e=[];for(;t<this.qByteLen;){this.v=await this.hmac(this.v);const r=this.v.slice();e.push(r),t+=this.v.length}return O(...e)}generateSync(){this.checkSync(),this.incr();let t=0;const e=[];for(;t<this.qByteLen;){this.v=this.hmacSync(this.v);const r=this.v.slice();e.push(r),t+=this.v.length}return O(...e)}}function W(t){return i<t&&t<u.n}function J(t){return i<t&&t<u.P}function F(t,e,r,n=!0){const{n:s}=u,a=K(t,!0);if(!W(a))return;const c=D(a,s),h=S.BASE.multiply(a),f=R(h.x,s);if(f===i)return;const l=R(c*R(e+r*f,s),s);if(l===i)return;let d=new B(f,l),y=(h.x===d.r?0:2)|Number(h.y&o);return n&&d.hasHighS()&&(d=d.normalizeS(),y^=1),{sig:d,recovery:y}}function Z(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(t.length!==2*d)throw new Error("Expected 32 bytes of private key");e=k(t)}else{if(!(t instanceof Uint8Array))throw new TypeError("Expected valid private key");if(t.length!==d)throw new Error("Expected 32 bytes of private key");e=M(t)}if(!W(e))throw new Error("Expected private key: 0 < key < n");return e}function G(t){return t instanceof S?(t.assertValidity(),t):S.fromHex(t)}function X(t){if(t instanceof B)return t.assertValidity(),t;try{return B.fromDER(t)}catch(e){return B.fromCompact(t)}}function Y(t){const e=t instanceof Uint8Array,r="string"==typeof t,n=(e||r)&&t.length;return e?n===y||n===p:r?n===2*y||n===2*p:t instanceof S}function Q(t){return M(t.length>l?t.slice(0,l):t)}function tt(t){const e=Q(t),r=R(e,u.n);return et(r<i?e:r)}function et(t){return U(t)}function rt(t,r,n){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const i=N(t),o=Z(r),s=[et(o),tt(i)];if(null!=n){!0===n&&(n=e.utils.randomBytes(l));const t=N(n);if(t.length!==l)throw new Error(`sign: Expected ${l} bytes of extra data`);s.push(t)}return{seed:O(...s),m:Q(i),d:o}}function nt(t,e){const{sig:r,recovery:n}=t,{der:i,recovered:o}=Object.assign({canonical:!0,der:!0},e),s=i?r.toDERRawBytes():r.toCompactRawBytes();return o?[s,n]:s}e.getPublicKey=function(t,e=!1){return S.fromPrivateKey(t).toRawBytes(e)},e.recoverPublicKey=function(t,e,r,n=!1){return S.fromSignature(t,e,r).toRawBytes(n)},e.getSharedSecret=function(t,e,r=!1){if(Y(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!Y(e))throw new TypeError("getSharedSecret: second arg must be public key");const n=G(e);return n.assertValidity(),n.multiply(Z(t)).toRawBytes(r)},e.sign=async function(t,e,r={}){const{seed:n,m:i,d:o}=rt(t,e,r.extraEntropy),s=new V(32,d);let a;for(await s.reseed(n);!(a=F(await s.generate(),i,o,r.canonical));)await s.reseed();return nt(a,r)},e.signSync=function(t,e,r={}){const{seed:n,m:i,d:o}=rt(t,e,r.extraEntropy),s=new V(32,d);let a;for(s.reseedSync(n);!(a=F(s.generateSync(),i,o,r.canonical));)s.reseedSync();return nt(a,r)};const it={strict:!0};function ot(t){return R(M(t),u.n)}e.verify=function(t,e,r,n=it){let i;try{i=X(t),e=N(e)}catch(t){return!1}const{r:o,s}=i;if(n.strict&&i.hasHighS())return!1;const a=K(e);let c;try{c=G(r)}catch(t){return!1}const{n:h}=u,f=D(s,h),l=R(a*f,h),d=R(o*f,h),y=S.BASE.multiplyAndAddUnsafe(c,l,d);return!!y&&R(y.x,h)===o};class st{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=N(t);if(64!==e.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const r=M(e.subarray(0,32)),n=M(e.subarray(32,64));return new st(r,n)}assertValidity(){const{r:t,s:e}=this;if(!J(t)||!W(e))throw new Error("Invalid signature")}toHex(){return T(this.r)+T(this.s)}toRawBytes(){return I(this.toHex())}}class at{constructor(t,r,n=e.utils.randomBytes()){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);this.m=N(t);const{x:i,scalar:o}=this.getScalar(Z(r));if(this.px=i,this.d=o,this.rand=N(n),32!==this.rand.length)throw new TypeError("sign: Expected 32 bytes of aux randomness")}getScalar(t){const e=S.fromPrivateKey(t),r=e.hasEvenY()?t:u.n-t;return{point:e,scalar:r,x:e.toRawX()}}initNonce(t,e){return U(t^M(e))}finalizeNonce(t){const e=R(M(t),u.n);if(e===i)throw new Error("sign: Creation of signature failed. k is zero");const{point:r,x:n,scalar:o}=this.getScalar(e);return{R:r,rx:n,k:o}}finalizeSig(t,e,r,n){return new st(t.x,R(e+r*n,u.n)).toRawBytes()}error(){throw new Error("sign: Invalid signature produced")}async calc(){const{m:t,d:r,px:n,rand:i}=this,o=e.utils.taggedHash,s=this.initNonce(r,await o(dt.aux,i)),{R:a,rx:c,k:u}=this.finalizeNonce(await o(dt.nonce,s,n,t)),h=ot(await o(dt.challenge,c,n,t)),f=this.finalizeSig(a,u,h,r);return await ht(f,t,n)||this.error(),f}calcSync(){const{m:t,d:r,px:n,rand:i}=this,o=e.utils.taggedHashSync,s=this.initNonce(r,o(dt.aux,i)),{R:a,rx:c,k:u}=this.finalizeNonce(o(dt.nonce,s,n,t)),h=ot(o(dt.challenge,c,n,t)),f=this.finalizeSig(a,u,h,r);return ft(f,t,n)||this.error(),f}}function ct(t,e,r){const n=t instanceof st,i=n?t:st.fromHex(t);return n&&i.assertValidity(),{...i,m:N(e),P:G(r)}}function ut(t,e,r,n){const i=S.BASE.multiplyAndAddUnsafe(e,Z(r),R(-n,u.n));return!(!i||!i.hasEvenY()||i.x!==t)}async function ht(t,r,n){try{const{r:i,s:o,m:s,P:a}=ct(t,r,n),c=ot(await e.utils.taggedHash(dt.challenge,U(i),a.toRawX(),s));return ut(i,a,o,c)}catch(t){return!1}}function ft(t,r,n){try{const{r:i,s:o,m:s,P:a}=ct(t,r,n),c=ot(e.utils.taggedHashSync(dt.challenge,U(i),a.toRawX(),s));return ut(i,a,o,c)}catch(t){if(t instanceof b)throw t;return!1}}e.schnorr={Signature:st,getPublicKey:function(t){return S.fromPrivateKey(t).toRawX()},sign:async function(t,e,r){return new at(t,e,r).calc()},verify:ht,signSync:function(t,e,r){return new at(t,e,r).calcSync()},verifySync:ft},S.BASE._setWindowSize(8);const lt={node:n,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},dt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},yt={};e.utils={bytesToHex:C,hexToBytes:I,concatBytes:O,mod:R,invert:D,isValidPrivateKey(t){try{return Z(t),!0}catch(t){return!1}},_bigintTo32Bytes:U,_normalizePrivateKey:Z,hashToPrivateKey:t=>{t=N(t);const e=d+8;if(t.length<e||t.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");return U(R(M(t),u.n-o)+o)},randomBytes:(t=32)=>{if(lt.web)return lt.web.getRandomValues(new Uint8Array(t));if(lt.node){const{randomBytes:e}=lt.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>e.utils.hashToPrivateKey(e.utils.randomBytes(d+8)),precompute(t=8,e=S.BASE){const r=e===S.BASE?e:new S(e.x,e.y);return r._setWindowSize(t),r.multiply(a),r},sha256:async(...t)=>{if(lt.web){const e=await lt.web.subtle.digest("SHA-256",O(...t));return new Uint8Array(e)}if(lt.node){const{createHash:e}=lt.node,r=e("sha256");return t.forEach((t=>r.update(t))),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(lt.web){const r=await lt.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),n=O(...e),i=await lt.web.subtle.sign("HMAC",r,n);return new Uint8Array(i)}if(lt.node){const{createHmac:r}=lt.node,n=r("sha256",t);return e.forEach((t=>n.update(t))),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...r)=>{let n=yt[t];if(void 0===n){const r=await e.utils.sha256(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=O(r,r),yt[t]=n}return e.utils.sha256(n,...r)},taggedHashSync:(t,...e)=>{if("function"!=typeof q)throw new b("sha256Sync is undefined, you need to set it");let r=yt[t];if(void 0===r){const e=q(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=O(e,e),yt[t]=r}return q(r,...e)},_JacobianPoint:v},Object.defineProperties(e.utils,{sha256Sync:{configurable:!1,get:()=>q,set(t){q||(q=t)}},hmacSha256Sync:{configurable:!1,get:()=>z,set(t){z||(z=t)}}})},742:(t,e)=>{"use strict";e.byteLength=function(t){var e=a(t),r=e[0],n=e[1];return 3*(r+n)/4-n},e.toByteArray=function(t){var e,r,o=a(t),s=o[0],c=o[1],u=new i(function(t,e,r){return 3*(e+r)/4-r}(0,s,c)),h=0,f=c>0?s-4:s;for(r=0;r<f;r+=4)e=n[t.charCodeAt(r)]<<18|n[t.charCodeAt(r+1)]<<12|n[t.charCodeAt(r+2)]<<6|n[t.charCodeAt(r+3)],u[h++]=e>>16&255,u[h++]=e>>8&255,u[h++]=255&e;return 2===c&&(e=n[t.charCodeAt(r)]<<2|n[t.charCodeAt(r+1)]>>4,u[h++]=255&e),1===c&&(e=n[t.charCodeAt(r)]<<10|n[t.charCodeAt(r+1)]<<4|n[t.charCodeAt(r+2)]>>2,u[h++]=e>>8&255,u[h++]=255&e),u},e.fromByteArray=function(t){for(var e,n=t.length,i=n%3,o=[],s=16383,a=0,u=n-i;a<u;a+=s)o.push(c(t,a,a+s>u?u:a+s));return 1===i?(e=t[n-1],o.push(r[e>>2]+r[e<<4&63]+"==")):2===i&&(e=(t[n-2]<<8)+t[n-1],o.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+"=")),o.join("")};for(var r=[],n=[],i="undefined"!=typeof Uint8Array?Uint8Array:Array,o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0;s<64;++s)r[s]=o[s],n[o.charCodeAt(s)]=s;function a(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function c(t,e,n){for(var i,o,s=[],a=e;a<n;a+=3)i=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(255&t[a+2]),s.push(r[(o=i)>>18&63]+r[o>>12&63]+r[o>>6&63]+r[63&o]);return s.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},764:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.decode=e.encode=e.unescape=e.escape=e.pad=void 0;const n=r(742);function i(t){return`${t}${"=".repeat(4-(t.length%4||4))}`}function o(t){return t.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function s(t){return i(t).replace(/-/g,"+").replace(/_/g,"/")}e.pad=i,e.escape=o,e.unescape=s,e.encode=function(t){return o((0,n.fromByteArray)((new TextEncoder).encode(t)))},e.decode=function(t){return(new TextDecoder).decode((0,n.toByteArray)(i(s(t))))}},803:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.cryptoClients=e.SECP256K1Client=void 0;const n=r(118);Object.defineProperty(e,"SECP256K1Client",{enumerable:!0,get:function(){return n.SECP256K1Client}});const i={ES256K:n.SECP256K1Client};e.cryptoClients=i},118:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SECP256K1Client=void 0;const n=r(569),i=r(61),o=r(656),s=r(563),a=r(581),c=r(89);o.utils.hmacSha256Sync=(t,...e)=>{const r=n.hmac.create(i.sha256,t);return e.forEach((t=>r.update(t))),r.digest()};class u{static derivePublicKey(t,e=!0){return 66===t.length&&(t=t.slice(0,64)),t.length<64&&(t=t.padStart(64,"0")),(0,c.bytesToHex)(o.getPublicKey(t,e))}static signHash(t,e,r="jose"){if(!t||!e)throw new a.MissingParametersError("a signing input hash and private key are all required");const n=o.signSync(t,e.slice(0,64),{der:!0,canonical:!1});if("der"===r)return(0,c.bytesToHex)(n);if("jose"===r)return(0,s.derToJose)(n,"ES256");throw Error("Invalid signature format")}static loadSignature(t){return(0,s.joseToDer)(t,"ES256")}static verifyHash(t,e,r){if(!t||!e||!r)throw new a.MissingParametersError("a signing input hash, der signature, and public key are all required");return o.verify(e,t,r,{strict:!1})}}e.SECP256K1Client=u,u.algorithmName="ES256K"},674:function(t,e,r){"use strict";var n=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(i,o){function s(t){try{c(n.next(t))}catch(t){o(t)}}function a(t){try{c(n.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?i(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(s,a)}c((n=n.apply(t,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.hashSha256Async=e.hashSha256=void 0;const i=r(61);function o(t){return(0,i.sha256)(t)}e.hashSha256=o,e.hashSha256Async=function(t){return n(this,void 0,void 0,(function*(){try{if("undefined"!=typeof crypto&&void 0!==crypto.subtle){const e="string"==typeof t?(new TextEncoder).encode(t):t,r=yield crypto.subtle.digest("SHA-256",e);return new Uint8Array(r)}{const e=r(971);if(!e.createHash)throw new Error("`crypto` module does not contain `createHash`");return Promise.resolve(e.createHash("sha256").update(t).digest())}}catch(e){return console.log(e),console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'),Promise.resolve(o(t))}}))}},891:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.decodeToken=void 0;const n=r(764);e.decodeToken=function(t){if("string"==typeof t){const e=t.split(".");return{header:JSON.parse(n.decode(e[0])),payload:JSON.parse(n.decode(e[1])),signature:e[2]}}if("object"==typeof t){if("string"!=typeof t.payload)throw new Error("Expected token payload to be a base64 or json string");let e=t.payload;"{"!==t.payload[0]&&(e=n.decode(e));const r=[];return t.header.map((t=>{const e=JSON.parse(n.decode(t));r.push(e)})),{header:r,payload:JSON.parse(e),signature:t.signature}}}},563:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.joseToDer=e.derToJose=void 0;const n=r(742),i=r(764);function o(t){return(t/8|0)+(t%8==0?0:1)}const s={ES256:o(256),ES384:o(384),ES512:o(521)};function a(t){const e=s[t];if(e)return e;throw new Error(`Unknown algorithm "${t}"`)}const c=128;function u(t){if(t instanceof Uint8Array)return t;if("string"==typeof t)return(0,n.toByteArray)((0,i.pad)(t));throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array")}function h(t,e,r){let n=0;for(;e+n<r&&0===t[e+n];)++n;return t[e+n]>=c&&--n,n}e.derToJose=function(t,e){const r=u(t),o=a(e),s=o+1,c=r.length;let h=0;if(48!==r[h++])throw new Error('Could not find expected "seq"');let f=r[h++];if(129===f&&(f=r[h++]),c-h<f)throw new Error(`"seq" specified length of "${f}", only "${c-h}" remaining`);if(2!==r[h++])throw new Error('Could not find expected "int" for "r"');const l=r[h++];if(c-h-2<l)throw new Error(`"r" specified length of "${l}", only "${c-h-2}" available`);if(s<l)throw new Error(`"r" specified length of "${l}", max of "${s}" is acceptable`);const d=h;if(h+=l,2!==r[h++])throw new Error('Could not find expected "int" for "s"');const y=r[h++];if(c-h!==y)throw new Error(`"s" specified length of "${y}", expected "${c-h}"`);if(s<y)throw new Error(`"s" specified length of "${y}", max of "${s}" is acceptable`);const p=h;if(h+=y,h!==c)throw new Error(`Expected to consume entire array, but "${c-h}" bytes remain`);const g=o-l,w=o-y,b=new Uint8Array(g+l+w+y);for(h=0;h<g;++h)b[h]=0;b.set(r.subarray(d+Math.max(-g,0),d+l),h),h=o;for(const t=h;h<t+w;++h)b[h]=0;return b.set(r.subarray(p+Math.max(-w,0),p+y),h),(0,i.escape)((0,n.fromByteArray)(b))},e.joseToDer=function(t,e){t=u(t);const r=a(e),n=t.length;if(n!==2*r)throw new TypeError(`"${e}" signatures must be "${2*r}" bytes, saw "${n}"`);const i=h(t,0,r),o=h(t,r,t.length),s=r-i,f=r-o,l=2+s+1+1+f,d=l<c,y=new Uint8Array((d?2:3)+l);let p=0;return y[p++]=48,d?y[p++]=l:(y[p++]=129,y[p++]=255&l),y[p++]=2,y[p++]=s,i<0?(y[p++]=0,y.set(t.subarray(0,r),p),p+=r):(y.set(t.subarray(i,r),p),p+=r-i),y[p++]=2,y[p++]=f,o<0?(y[p++]=0,y.set(t.subarray(r),p)):y.set(t.subarray(r+o),p),y}},581:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.InvalidTokenError=e.MissingParametersError=void 0;class r extends Error{constructor(t){super(),this.name="MissingParametersError",this.message=t||""}}e.MissingParametersError=r;class n extends Error{constructor(t){super(),this.name="InvalidTokenError",this.message=t||""}}e.InvalidTokenError=n},80:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(e,r);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,i)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),i=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),i(r(298),e),i(r(523),e),i(r(891),e),i(r(581),e),i(r(803),e)},298:function(t,e,r){"use strict";var n=this&&this.__awaiter||function(t,e,r,n){return new(r||(r=Promise))((function(i,o){function s(t){try{c(n.next(t))}catch(t){o(t)}}function a(t){try{c(n.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?i(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(s,a)}c((n=n.apply(t,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.TokenSigner=e.createUnsecuredToken=void 0;const i=r(764),o=r(803),s=r(581),a=r(674);function c(t,e){const r=[],n=i.encode(JSON.stringify(e));r.push(n);const o=i.encode(JSON.stringify(t));return r.push(o),r.join(".")}e.createUnsecuredToken=function(t){return c(t,{typ:"JWT",alg:"none"})+"."},e.TokenSigner=class{constructor(t,e){if(!t||!e)throw new s.MissingParametersError("a signing algorithm and private key are required");if("string"!=typeof t)throw new Error("signing algorithm parameter must be a string");if(t=t.toUpperCase(),!o.cryptoClients.hasOwnProperty(t))throw new Error("invalid signing algorithm");this.tokenType="JWT",this.cryptoClient=o.cryptoClients[t],this.rawPrivateKey=e}header(t={}){const e={typ:this.tokenType,alg:this.cryptoClient.algorithmName};return Object.assign({},e,t)}sign(t,e=!1,r={}){const n=this.header(r),i=c(t,n),o=(0,a.hashSha256)(i);return this.createWithSignedHash(t,e,n,i,o)}signAsync(t,e=!1,r={}){return n(this,void 0,void 0,(function*(){const n=this.header(r),i=c(t,n),o=yield(0,a.hashSha256Async)(i);return this.createWithSignedHash(t,e,n,i,o)}))}createWithSignedHash(t,e,r,n,o){const s=this.cryptoClient.signHash(o,this.rawPrivateKey);return e?{header:[i.encode(JSON.stringify(r))],payload:JSON.stringify(t),signature:[s]}:[n,s].join(".")}}},523:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.TokenVerifier=void 0;const n=r(764),i=r(803),o=r(581),s=r(674);e.TokenVerifier=class{constructor(t,e){if(!t||!e)throw new o.MissingParametersError("a signing algorithm and public key are required");if("string"!=typeof t)throw"signing algorithm parameter must be a string";if(t=t.toUpperCase(),!i.cryptoClients.hasOwnProperty(t))throw"invalid signing algorithm";this.tokenType="JWT",this.cryptoClient=i.cryptoClients[t],this.rawPublicKey=e}verify(t){return"string"==typeof t?this.verifyCompact(t,!1):"object"==typeof t&&this.verifyExpanded(t,!1)}verifyAsync(t){return"string"==typeof t?this.verifyCompact(t,!0):"object"==typeof t?this.verifyExpanded(t,!0):Promise.resolve(!1)}verifyCompact(t,e){const r=t.split("."),n=r[0]+"."+r[1],i=t=>{const e=this.cryptoClient.loadSignature(r[2]);return this.cryptoClient.verifyHash(t,e,this.rawPublicKey)};if(e)return(0,s.hashSha256Async)(n).then((t=>i(t)));{const t=(0,s.hashSha256)(n);return i(t)}}verifyExpanded(t,e){const r=[t.header.join("."),n.encode(t.payload)].join(".");let i=!0;const o=e=>(t.signature.map((t=>{const r=this.cryptoClient.loadSignature(t);this.cryptoClient.verifyHash(e,r,this.rawPublicKey)||(i=!1)})),i);if(e)return(0,s.hashSha256Async)(r).then((t=>o(t)));{const t=(0,s.hashSha256)(r);return o(t)}}}},530:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(e,r);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,i)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),i=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),i(r(859),e),i(r(497),e),i(r(337),e),i(r(715),e),i(r(248),e)},859:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(e,r);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,i)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),i=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),e.getAddress=void 0;const o=r(80);e.getAddress=async t=>{const{message:e,network:r,purposes:n}=t.payload,i=window.BitcoinProvider;if(!i)throw new Error("No Bitcoin Wallet installed");if(!n)throw new Error("Address purposes are required");try{const e=(0,o.createUnsecuredToken)(t.payload),r=await i.connect(e);t.onFinish?.(r)}catch(e){console.error("[Connect] Error during address request",e),t.onCancel?.()}},i(r(252),e)},252:(t,e)=>{"use strict";var r;Object.defineProperty(e,"__esModule",{value:!0}),e.AddressPurposes=void 0,(r=e.AddressPurposes||(e.AddressPurposes={})).PAYMENT="payment",r.ORDINALS="ordinals"},337:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.callWalletPopup=e.CallMethod=void 0;const n=r(80);var i;(i=e.CallMethod||(e.CallMethod={})).SIGN_TRANSACTION="signTransaction",i.GET_ADDRESS="getAddress",e.callWalletPopup=async t=>{const e=window.BitcoinProvider,{method:r}=t.payload;if(!e)throw new Error("No Bitcoin Wallet installed");if(!r)throw new Error("A wallet method is required");const i=(0,n.createUnsecuredToken)(t.payload);try{const r=await e.call(i);t.onFinish?.(r)}catch(e){console.error("[Connect] Error during call request",e),t.onCancel?.()}}},497:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0})},248:function(t,e,r){"use strict";var n=this&&this.__createBinding||(Object.create?function(t,e,r,n){void 0===n&&(n=r);var i=Object.getOwnPropertyDescriptor(e,r);i&&!("get"in i?!e.__esModule:i.writable||i.configurable)||(i={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,n,i)}:function(t,e,r,n){void 0===n&&(n=r),t[n]=e[r]}),i=this&&this.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||n(e,t,r)};Object.defineProperty(e,"__esModule",{value:!0}),e.signMessage=void 0;const o=r(80);e.signMessage=async t=>{const e=window.BitcoinProvider;if(!e)throw new Error("No Bitcoin Wallet installed");try{const r=(0,o.createUnsecuredToken)(t.payload),n=await e.signMessage(r);t.onFinish?.(n)}catch(e){console.error("[Connect] Error during Signing request",e),t.onCancel?.()}},i(r(292),e)},292:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0})},715:(t,e,r)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.signTransaction=void 0;const n=r(80);e.signTransaction=async t=>{const{psbtBase64:e,inputsToSign:r}=t.payload,i=window.BitcoinProvider;if(!i)throw new Error("No Bitcoin Wallet installed");if(!e)throw new Error("a value for psbtBase64 representing the tx hash is required");if(!r)throw new Error("an array specifying the inputs to be signed by the wallet is required");try{const e=(0,n.createUnsecuredToken)(t.payload),r=await i.signTransaction(e);t.onFinish?.(r)}catch(e){console.error("[Connect] Error during signPsbt request",e),t.onCancel?.()}}},159:()=>{},971:()=>{}},n={};function i(t){var e=n[t];if(void 0!==e)return e.exports;var o=n[t]={exports:{}};return r[t].call(o.exports,o,o.exports,i),o.exports}e=Object.getPrototypeOf?t=>Object.getPrototypeOf(t):t=>t.__proto__,i.t=function(r,n){if(1&n&&(r=this(r)),8&n)return r;if("object"==typeof r&&r){if(4&n&&r.__esModule)return r;if(16&n&&"function"==typeof r.then)return r}var o=Object.create(null);i.r(o);var s={};t=t||[null,e({}),e([]),e(e)];for(var a=2&n&&r;"object"==typeof a&&!~t.indexOf(a);a=e(a))Object.getOwnPropertyNames(a).forEach((t=>s[t]=()=>r[t]));return s.default=()=>r,i.d(o,s),o},i.d=(t,e)=>{for(var r in e)i.o(e,r)&&!i.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},(()=>{"use strict";var t,e=i(530);window.satsConnect=t||(t=i.t(e,2))})()})();